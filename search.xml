<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Faster RCNN阅读]]></title>
    <url>%2F2019%2F04%2F29%2FFaster-RCNN%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[test .tg {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:3px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:3px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-uys7{border-color:inherit;text-align:center}.tg .tg-xldj{border-color:inherit;text-align:left} base_anchor ratios 宽，高，中心点横坐标，中心点纵坐标 坐标 16x16 23x122:1 [184,96,7.5,7.5] scale=8 [ -84. -40. 99. 55.] [368,192,7.5,7.5] scale=16 [-176. -88. 191. 103.] [736,384,7.5,7.5] scale=32 [-360. -184. 375. 199.] 16x161:1 [128,128,7.5,7.5] scale=8 [ -56. -56. 71. 71.] [256,256,7.5,7.5] scale=16 [-120. -120. 135. 135.] [512,512,7.5,7.5] scale=32 [-248. -248. 263. 263.] 11x221:2 [88,176,7.5,7.5] scale=8 [ -36. -80. 51. 95.] [176,352,7.5,7.5] scale=16 [ -80. -168. 95. 183.] [352,704,7.5,7.5] scale=32 [-168. -344. 183. 359.]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Search Insert Position]]></title>
    <url>%2F2019%2F04%2F29%2FLeetcode035-Search%20Insert%20Position%2F</url>
    <content type="text"><![CDATA[Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 4: 12Input: [1,3,5,6], 0Output: 0 Solution: 1234567891011121314151617181920212223class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int res = 0; if (nums.size() == 0 || nums[0] &gt; target) &#123; return 0; &#125; else if (nums.back() &lt; target) &#123; return nums.size(); &#125; else &#123; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums[i] == target) &#123; res = i; &#125; if (nums[i] &lt; target &amp;&amp; nums[i+1] &gt;= target) &#123; res = i+1; &#125; &#125; return res; &#125; &#125;&#125;; Time Submitted Status Runtime Memory Language a few seconds ago Accepted 8 ms 8.9 MB cpp 12Runtime: 8 ms, faster than 98.61% of C++ online submissions for Search Insert Position.Memory Usage: 8.9 MB, less than 98.08% of C++ online submissions for Search Insert Position. 查找的部分应该还可以优化，用二分查找做还可以再快一点。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Remove Duplicates from Sorted Array]]></title>
    <url>%2F2019%2F04%2F23%2FLeetcode026-Remove%20Duplicates%20from%20Sorted%20Array%2F</url>
    <content type="text"><![CDATA[Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 12345Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: 12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; Solution:Vector在日常写程序用的比较多，所以看一眼就有了点想法。传入的是vector的引用，需要在原数组上操作，vector已经排序了，比较索引为i和i+1的元素是否相同就可以，因为美股元素只能出现一次，所以有两种解决办法，遇到相同的元素移到最后或者删除，移到最后还要额外增加一个变量来计算不同元素的数量，所以直接用删除的方式。需要注意的就是vector的删除问题，当删除索引为i的元素时，i后面的元素都会向前移动一位，要注意i++的索引的变化。 123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums[i] == nums[i + 1]) &#123; nums.erase(nums.begin() + i + 1); i--; //注意索引的变化 &#125; &#125; return nums.size(); &#125;&#125;; Time Submitted Status Runtime Memory Language a few seconds ago Accepted 156 ms 9.9 MB cpp 大神的solution： 1234567class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; nums.erase(std::unique(nums.begin(), nums.end()), nums.end()); return nums.size(); &#125;&#125;; Time Submitted Status Runtime Memory Language a few seconds ago Accepted 24 ms 9.8 MB cpp]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++多线程编程中std::future的使用]]></title>
    <url>%2F2019%2F04%2F22%2FC%2B%2B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%ADfuture%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近一直在搞多线程，C++的底子较烂，直接用.detach()方法创建线程，无法使输入顺序和输出顺序同步，而且输入数据在不断的产生，类似生产者和消费者问题，不断的创建新线程会浪费时间，所以想到用线程池的方法。 std::future是一个类模板(class template)，其对象存储未来的值，一个std::future对象在内部存储一个将来会被赋值的值，并提供了一个访问该值的机制，通过get()成员函数实现。但如果有人视图在get()函数可用之前通过它来访问相关的值，那么get()函数将会阻塞，直到该值可用。来源：https://blog.csdn.net/lijinqi1987/article/details/78507623 我理解这段话的意思就是因为多线程输出没办法控制输出的顺序，那么future就为所有会有输出的位置放一个占位符，认定这个位置会有一个输出，但是具体什么时间会有不确定。 测试结果： 来源：https://github.com/progschj/ThreadPool GitHub2k多star的一个线程池的项目，改了一下example，看输出更直观一些。 话说昨天有个小破站的后台源码被push上来了，golang的教程可能要火了，push一时爽，牢饭吃到老，职业道德还是要有的。 123456hello hello hello hello hello hello hello hello hello hello 1 2 0 1 2 2 0 1 0 0 world 1world 2 world 0 world 1 hello 2 world 2 world 2 hello 0 hello 3 world 0 world 0 hello 1hello 3 hello 0 hello 1 hello 2 world 0 world 1 hello 1 hello 2 world 2 world 0 hello 3 world 3 world 1 world 3 world 0world 1 world 2 world 2 world 1 world 30 1 2 0 1 2 0 1 2 0 1 2 3 0 1 2 3 0 1 2 3 可以发现，创建了10个线程，线程的执行是并行的，但是输出的结果和输出的顺序是一样的。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//*****************ThreadPool.h**********************#ifndef THREAD_POOL_H#define THREAD_POOL_H#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;memory&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;future&gt;#include &lt;functional&gt;#include &lt;stdexcept&gt;class ThreadPool &#123;public: ThreadPool(size_t); template&lt;class F, class... Args&gt; auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;; ~ThreadPool();private: // need to keep track of threads so we can join them std::vector&lt; std::thread &gt; workers; // the task queue std::queue&lt; std::function&lt;void()&gt; &gt; tasks; // synchronization std::mutex queue_mutex; std::condition_variable condition; bool stop;&#125;; // the constructor just launches some amount of workersinline ThreadPool::ThreadPool(size_t threads) : stop(false)&#123; for(size_t i = 0;i&lt;threads;++i) workers.emplace_back( [this] &#123; for(;;) &#123; std::function&lt;void()&gt; task; &#123; std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex); this-&gt;condition.wait(lock, [this]&#123; return this-&gt;stop || !this-&gt;tasks.empty(); &#125;); if(this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) return; task = std::move(this-&gt;tasks.front()); this-&gt;tasks.pop(); &#125; task(); &#125; &#125; );&#125;// add new work item to the pooltemplate&lt;class F, class... Args&gt;auto ThreadPool::enqueue(F&amp;&amp; f, Args&amp;&amp;... args) -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;&#123; using return_type = typename std::result_of&lt;F(Args...)&gt;::type; auto task = std::make_shared&lt; std::packaged_task&lt;return_type()&gt; &gt;( std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...) ); std::future&lt;return_type&gt; res = task-&gt;get_future(); &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); // don't allow enqueueing after stopping the pool if(stop) throw std::runtime_error("enqueue on stopped ThreadPool"); tasks.emplace([task]()&#123; (*task)(); &#125;); &#125; condition.notify_one(); return res;&#125;// the destructor joins all threadsinline ThreadPool::~ThreadPool()&#123; &#123; std::unique_lock&lt;std::mutex&gt; lock(queue_mutex); stop = true; &#125; condition.notify_all(); for(std::thread &amp;worker: workers) worker.join();&#125;#endif 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//*****************example.cpp**********************#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;chrono&gt;#include "ThreadPool.h"std::vector&lt;std::vector&lt;int&gt;&gt; a;int main()&#123; ThreadPool pool(10); //create a &lt;future&gt; vector to wait the output std::vector&lt; std::future&lt;std::vector&lt;int&gt;&gt; &gt; results; std::vector&lt;int&gt; batch = &#123;3, 3, 3&#125;; int m = 3; for (int b = 0; b &lt; batch.size(); b++) &#123; if (m &gt; 0) &#123; batch.push_back(4); &#125; for (int i = 0; i &lt; batch[b]; i++) &#123; results.emplace_back( pool.enqueue([i] &#123; std::vector&lt;int&gt; res = &#123;i&#125;; std::cout &lt;&lt; "hello " &lt;&lt; i &lt;&lt; " "; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout &lt;&lt; "world " &lt;&lt; i &lt;&lt; " "; return res; &#125;)); &#125; m--; &#125; //get output for(auto &amp;&amp; result: results) a.emplace_back(result.get()); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; //after get all output, print it for (int i = 0; i &lt; a.size(); i++) &#123; for (int j = 0; j &lt; a[i].size(); j++) std::cout &lt;&lt; a[i][j] &lt;&lt; " "; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Valid Parentheses]]></title>
    <url>%2F2019%2F04%2F11%2FLeetcode020-Valid%20Parentheses%2F</url>
    <content type="text"><![CDATA[之前就看到这道题，没想到好的方法，正好最近在搞数据结构，到栈这里一个应用就是括号的匹配。 Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: 12Input: &quot;()&quot;Output: true Example 2: 12Input: &quot;()[]&#123;&#125;&quot;Output: true Example 3: 12Input: &quot;(]&quot;Output: false Example 4: 12Input: &quot;([)]&quot;Output: false Example 5: 12Input: &quot;&#123;[]&#125;&quot;Output: true Solution: 123456789101112131415161718192021222324252627class Solution &#123;public: bool isValid(string str) &#123; stack&lt;char&gt; s1; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] == &apos;(&apos; || str[i] == &apos;[&apos; || str[i] == &apos;&#123;&apos;) &#123; s1.push(str[i]); &#125; else if (str[i] == &apos;)&apos; || str[i] == &apos;]&apos; || str[i] == &apos;&#125;&apos;) &#123; if (s1.empty()) &#123; return false; &#125; else if ((s1.top()==&apos;(&apos; &amp;&amp; str[i]==&apos;)&apos;) || (s1.top()==&apos;[&apos; &amp;&amp; str[i]==&apos;]&apos;) || (s1.top()==&apos;&#123;&apos; &amp;&amp; str[i]==&apos;&#125;&apos;)) &#123; s1.pop(); &#125; else &#123; return false; &#125; &#125; &#125; if (s1.empty()) return true; else return false; &#125;&#125;; 数据结构果然很重要啊！！！ Time Submitted Status Runtime Memory Language a few seconds ago Accepted 4 ms 8.4 MB cpp]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++栈实现分隔符的匹配]]></title>
    <url>%2F2019%2F04%2F08%2FC%2B%2B%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%88%86%E9%9A%94%E7%AC%A6%E7%9A%84%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[栈是一种后进先出(LIFO)的线性数据结构。 栈适用于数据存储后以相反的顺序来检索的情况。站的一个应用是在程序中匹配分隔符。 在C++程序中存在下列分隔符：圆括号”(“和”)“、方括号”[“和”]“、花括号”{“和”}“、注释分隔符”/*“和”*/“ 栈的操作： clear()——清空栈。 isEmpty()——判断栈是否为空。 push(el)——将元素el放到栈的顶部。 pop()——弹出栈顶部的元素。 topEL()——获取栈顶部的元素，不删除。 genStack.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344//******************* genStack.h ************************// generic class for vector implenmentation of stack#ifndef STACK#define STACK#include &lt;vector&gt;using namespace std;template&lt;class T, int capacity = 30&gt;class Stack &#123;public: Stack() &#123; pool.reserve(capacity); &#125; void clear() &#123; pool.clear(); &#125; bool isEmpty() const &#123; return pool.empty(); &#125; T&amp; topEl() &#123; return pool.back(); &#125; T pop() &#123; T el = pool.back(); pool.pop_back(); return el; &#125; void push(const T&amp; el) &#123; pool.push_back(el); &#125;private: vector&lt;T&gt; pool;&#125;;#endif genStack.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//******************* genStack.h ************************//用栈实现分隔符的匹配#include &lt;iostream&gt;#include &quot;genStack.h&quot;#include &lt;string&gt;using namespace std;int main() &#123; string str = &quot;s=t[5]+u/(v*(w+y))&quot;; Stack&lt;char&gt; s1; for (int i = 0; i &lt; str.size(); i++) &#123; //注意单引号和双引号的使用！！！ if (str[i] == &apos;(&apos; || str[i] == &apos;[&apos; || str[i] == &apos;&#123;&apos;) &#123; s1.push(str[i]); //cout &lt;&lt; &quot;topEL: &quot; &lt;&lt; s1.topEl() &lt;&lt; endl; &#125; else if (str[i] == &apos;)&apos; || str[i] == &apos;]&apos; || str[i] == &apos;&#125;&apos;) &#123; if ((s1.topEl()==&apos;(&apos; &amp;&amp; str[i]==&apos;)&apos;) || (s1.topEl()==&apos;[&apos; &amp;&amp; str[i]==&apos;]&apos;) || (s1.topEl()==&apos;&#123;&apos; &amp;&amp; str[i]==&apos;&#125;&apos;)) &#123; s1.pop(); &#125; else &#123; cout &lt;&lt; &quot;error!&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; &#125; else if (str[i] == &apos;/&apos;) &#123; if (str[i + 1] == &apos;*&apos;) &#123; for (int j = i; j &lt; str.size(); j++) &#123; if (str[j] == &apos;*&apos; &amp;&amp; str[j + 1] == &apos;/&apos;) &#123; i = j + 1; break; &#125; else if (j == str.size()-1) &#123; cout &lt;&lt; &quot;&apos;/*&apos; can not match &apos;*/&apos;&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; &#125; &#125; else continue; &#125; &#125; if (s1.isEmpty()) cout &lt;&lt; &quot;success!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;failed!&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Longest Common Prefix]]></title>
    <url>%2F2019%2F03%2F31%2FLeetcode014-Longest%20Common%20Prefix%2F</url>
    <content type="text"><![CDATA[Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Solution： 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() == 0) return ""; int minlen = INT_MAX; string res = ""; for (int i = 0; i &lt; strs.size(); i++) &#123; if (strs[i].size() &lt; minlen) minlen = strs[i].size(); &#125; for (int i = 0; i &lt; minlen; i++) &#123; bool flag = true; for (int j = 0; j &lt; strs.size() - 1; j++) &#123; if (strs[j][i] != strs[j + 1][i]) flag = false; &#125; if (flag == true) res = res + strs[0][i]; else break; &#125; return res; &#125;&#125;; 没什么亮点的写法。 Time Submitted Status Runtime Memory Language a few seconds ago Accepted 8 ms 9.1 MB cpp]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++调用Python版Mask-R-CNN并传递和接收参数]]></title>
    <url>%2F2019%2F03%2F31%2FC%2B%2B%E8%B0%83%E7%94%A8Python%E7%89%88Mask-R-CNN%E5%B9%B6%E4%BC%A0%E9%80%92%E5%92%8C%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[想做一个用Mask R-CNN只检测人的demo，发现github已经有人用Python实现了，但后处理用的是C++，所以想直接用C++器调用python，再将需要的结果返回给C++。 运行环境： Visual Studio 2015，Python3.6（Anaconda），OpenCV3.4.2（C++），tensorflow1.12，Keras2.0.8 C++环境配置 配置OpenCV 新建一个C++工程； 右键属性$\rightarrow$C++目录$\rightarrow$包含目录$\rightarrow$点击编辑，将 123D:\Programs\opencv\build\includeD:\Programs\opencv\build\include\opencvD:\Programs\opencv\build\include\opencv2 加入包含目录，注意配置的方案平台版本和当前运行的一致； 右键属性$\rightarrow$C++目录$\rightarrow$库目录$\rightarrow$点击编辑，将 1D:\Programs\opencv\build\x64\vc14\lib 加入库目录，注意VS的版本，2017改用vc15的目录； 右键属性$\rightarrow$链接器$\rightarrow$输入$\rightarrow$点击编辑，将 1opencv_world342.lib 加入其中。 配置Python环境 右键属性$\rightarrow$C++目录$\rightarrow$包含目录$\rightarrow$点击编辑，将 12D:\Programs\Anaconda3\includeD:\Programs\Anaconda3\Lib\site-packages\numpy\core\include 加入到包含目录中； 右键属性$\rightarrow$C++目录$\rightarrow$库目录$\rightarrow$点击编辑，将 12D:\Programs\Anaconda3\libsD:\Programs\Anaconda3\Lib\site-packages\numpy\core\lib 加入库目录; 右键属性$\rightarrow$链接器$\rightarrow$输入$\rightarrow$点击编辑，将 1python36.lib 加入其中，注意只有python36，没有python36d，所以调试的时候要用relese的版本，debug的版本会报错。 调用Python 从C++输入图片数据 由于C++用OpenCV读取的图片格式和Mask R-CNN的输入格式不同，所以需要先用C++处理好图片，传递给Python。 12345678910111213141516171819202122232425262728Mat img = imread(&quot;./image.jpg&quot;);auto sz = img.size();int x = sz.width;int y = sz.height;int z = img.channels();uchar *CArrays = new uchar[x*y*z];int iChannels = img.channels();int iRows = img.rows;int iCols = img.cols * iChannels;if (img.isContinuous())&#123; iCols *= iRows; iRows = 1;&#125;uchar* p;int id = -1;for (int i = 0; i &lt; iRows; i++)&#123; // get the pointer to the ith row p = img.ptr&lt;uchar&gt;(i); // operates on each pixel for (int j = 0; j &lt; iCols; j++) &#123; CArrays[++id] = p[j];//连续空间 &#125;&#125;npy_intp Dims[3] = &#123;y, x, z&#125;; //注意这个维度数据！PyObject *PyArray = PyArray_SimpleNewFromData(3, Dims, NPY_UBYTE, CArrays); 调用Mask R-CNN 1234567891011121314151617181920212223242526272829303132333435363738394041//初始化pythonPy_Initialize();import_array();PyRun_SimpleString(&quot;import sys&quot;); PyRun_SimpleString(&quot;sys.path.append(r&apos;C:\\Users\\Administrator\\Documents\\Keypoints-of-humanpose-with-Mask-R-CNN-master&apos;)&quot;);//定义python类型的变量PyObject *pModule = NULL;PyObject *pFunc = NULL;PyObject *pArg = NULL;PyObject *result = NULL;PyObject *pDict = NULL;//直接运行python代码PyRun_SimpleString(&quot;print(&apos;python start&apos;)&quot;);PyObject *ArgList = PyTuple_New(1);...PyTuple_SetItem(ArgList, 0, PyArray);//引入模块pModule = PyImport_ImportModule(&quot;human_detected&quot;);if (!pModule)&#123; cout &lt;&lt; &quot;Import Module Failed&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;//获取模块字典属性pDict = PyModule_GetDict(pModule);//直接获取模块中的函数pFunc = PyObject_GetAttrString(pModule, &quot;detect&quot;);... Mask R-CNN接受参数并返回值 Mask R-CNN检测人项目地址：https://github.com/Junyuan12/Mask_RCNN_Humanpose Mask R-CNN的配置就不细说了，网上有很多教程，主要是windows下配置pycocotools可能会有问题， windows下pycocotools安装教程：https://blog.csdn.net/qq_29592829/article/details/82877494 在Mask R-CNN中新建一个py文件，human_detected.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import osimport sysimport randomimport mathimport numpy as npimport skimage.ioimport matplotlibimport matplotlib.pyplot as pltimport cocoimport utilsimport model as modellibimport visualizefrom model import logimport cv2def detect(image): # print(image) ROOT_DIR = os.getcwd() # Directory to save logs and trained model MODEL_DIR = os.path.join(ROOT_DIR, &quot;mylogs&quot;) # Local path to trained weights file COCO_MODEL_PATH = os.path.join(ROOT_DIR, &quot;mask_rcnn_coco_humanpose.h5&quot;) # Download COCO trained weights from Releases if needed if not os.path.exists(COCO_MODEL_PATH): utils.download_trained_weights(COCO_MODEL_PATH) class InferenceConfig(coco.CocoConfig): GPU_COUNT = 1 IMAGES_PER_GPU = 1 KEYPOINT_MASK_POOL_SIZE = 7 inference_config = InferenceConfig() # Recreate the model in inference mode model = modellib.MaskRCNN(mode=&quot;inference&quot;, config=inference_config, model_dir=MODEL_DIR) # Get path to saved weights model_path = os.path.join(ROOT_DIR, &quot;mask_rcnn_coco_humanpose.h5&quot;) assert model_path != &quot;&quot;, &quot;Provide path to trained weights&quot; print(&quot;Loading weights from &quot;, model_path) model.load_weights(model_path, by_name=True) # COCO Class names #For human pose task We just use &quot;BG&quot; and &quot;person&quot; class_names = [&apos;BG&apos;, &apos;person&apos;] #BGR-&gt;RGB image = image[:,:,::-1] #print(np.shape(image)) # Run detection results = model.detect_keypoint([image], verbose=1) r = results[0] # for one image log(&quot;rois&quot;,r[&apos;rois&apos;]) log(&quot;keypoints&quot;,r[&apos;keypoints&apos;]) log(&quot;class_ids&quot;,r[&apos;class_ids&apos;]) log(&quot;keypoints&quot;,r[&apos;keypoints&apos;]) log(&quot;masks&quot;,r[&apos;masks&apos;]) log(&quot;scores&quot;,r[&apos;scores&apos;]) visualize.display_instances(image, r[&apos;rois&apos;], r[&apos;masks&apos;], r[&apos;class_ids&apos;], class_names, r[&apos;scores&apos;]) flat_roi = r[&apos;rois&apos;].flatten() print(flat_roi) return flat_roi 其中包括一个函数detect(image)，用于接受C++传进来的图片，并最终返回每个人的roi。 C++接受返回参数 python将结果展开成一列，C++接受返回的一维数组并输出： 1234567891011121314151617181920212223// 调用直接获得的函数,并传递参数PyObject *pReturn = PyObject_CallObject(pFunc, ArgList);//获取python程序的返回结果//以下是对返回的一维数组结果进行处理if (pReturn)&#123; //将结果类型转换成数组对象类型 PyArrayObject *pyResultArr = (PyArrayObject *)pReturn; //从Python中的PyArrayObject解析出数组数据为c的double类型。 int *resDataArr = (int *)PyArray_DATA(pyResultArr); int dimNum = PyArray_NDIM(pyResultArr);//返回数组的维度数，此处恒为1 npy_intp *pdim = PyArray_DIMS(pyResultArr);//返回数组各维度上的元素个数值 //以下是对返回结果的输出显示 for (int i = 0; i &lt; dimNum; ++i) &#123; for (int j = 0; j &lt; pdim[0]; ++j) cout &lt;&lt; resDataArr[i * pdim[0] + j] &lt;&lt; &quot;,&quot;; &#125; cout &lt;&lt; endl;&#125; 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;Python.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;numpy/arrayobject.h&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;using namespace std;int main(int argc, char* argv[])&#123; cv::Mat img = cv::imread(&quot;./image.jpg&quot;); //初始化python Py_Initialize(); import_array(); PyRun_SimpleString(&quot;import sys&quot;); PyRun_SimpleString(&quot;sys.path.append(r&apos;C:\\Users\\Administrator\\Documents\\Keypoints-of-humanpose-with-Mask-R-CNN-master&apos;)&quot;); //PyRun_SimpleString(&quot;print(sys.path)&quot;); //定义python类型的变量 PyObject *pModule = NULL; PyObject *pFunc = NULL; PyObject *pArg = NULL; PyObject *result = NULL; PyObject *pDict = NULL; //直接运行python代码 PyRun_SimpleString(&quot;print(&apos;python start&apos;)&quot;); PyObject *ArgList = PyTuple_New(1); auto sz = img.size(); int x = sz.width; int y = sz.height; int z = img.channels(); uchar *CArrays = new uchar[x*y*z]; int iChannels = img.channels(); int iRows = img.rows; int iCols = img.cols * iChannels; if (img.isContinuous()) &#123; iCols *= iRows; iRows = 1; &#125; uchar* p; int id = -1; for (int i = 0; i &lt; iRows; i++) &#123; // get the pointer to the ith row p = img.ptr&lt;uchar&gt;(i); // operates on each pixel for (int j = 0; j &lt; iCols; j++) &#123; CArrays[++id] = p[j];//连续空间 &#125; &#125; npy_intp Dims[3] = &#123; y, x, z &#125;; //注意这个维度数据！ PyObject *PyArray = PyArray_SimpleNewFromData(3, Dims, NPY_UBYTE, CArrays); PyTuple_SetItem(ArgList, 0, PyArray); //引入模块 pModule = PyImport_ImportModule(&quot;human_detected&quot;); if (!pModule) &#123; cout &lt;&lt; &quot;Import Module Failed&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; &#125; //获取模块字典属性 pDict = PyModule_GetDict(pModule); //直接获取模块中的函数 pFunc = PyObject_GetAttrString(pModule, &quot;detect&quot;); // 调用直接获得的函数,并传递参数 PyObject *pReturn = PyObject_CallObject(pFunc, ArgList); //获取python程序的返回结果 //以下是对返回的一维数组结果进行处理 if (pReturn) &#123; //将结果类型转换成数组对象类型 PyArrayObject *pyResultArr = (PyArrayObject *)pReturn; //从Python中的PyArrayObject解析出数组数据为c的double类型。 int *resDataArr = (int *)PyArray_DATA(pyResultArr); int dimNum = PyArray_NDIM(pyResultArr);//返回数组的维度数，此处恒为1 npy_intp *pdim = PyArray_DIMS(pyResultArr);//返回数组各维度上的元素个数值 //以下是对返回结果的输出显示 for (int i = 0; i &lt; dimNum; ++i) &#123; for (int j = 0; j &lt; pdim[0]; ++j) cout &lt;&lt; resDataArr[i * pdim[0] + j] &lt;&lt; &quot;,&quot;; &#125; cout &lt;&lt; endl; &#125; PyRun_SimpleString(&quot;print(&apos;python end&apos;)&quot;); ////释放python Py_Finalize(); system(&quot;pause&quot;); return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Roman to Integer]]></title>
    <url>%2F2019%2F03%2F29%2FLeetcode013-Roman%20to%20Integer%2F</url>
    <content type="text"><![CDATA[Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 最开始想用每种情况都写一遍，虽然会的不多，但还是嫌麻烦，想到了Python中的用两个list去对应相同的索引的不同类型，所以用数组老对应不同的罗马符号。 Solution： 1234567891011121314151617181920212223242526272829class Solution &#123;public: int romanToInt(string s) &#123; int num[] = &#123;1, 5, 10, 50, 100, 500, 1000&#125;; string rom = &quot;IVXLCDM&quot;; vector&lt;int&gt; tmp; int res = 0; for (int i = 0; i &lt; s.size(); i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; if (s[i] == rom[j]) tmp.push_back(num[j]); &#125; &#125; for (int i = 0; i &lt; tmp.size(); i++) &#123; if (i == tmp.size() - 1 || tmp[i] &gt;= tmp[i + 1]) &#123; res += tmp[i]; &#125; else &#123; res -= tmp[i]; &#125; &#125; return res; &#125;&#125;; if (i == tmp.size() - 1 || tmp[i] &gt;= tmp[i + 1])，这里最开始是if(tmp[i] &gt;= tmp[i + 1])，处理&quot;MCDLXXVI&quot;时报错了，输出结果发现最后的I并没有加进去，很神奇，原因还没找到，先留个坑。 Time Submitted Status Runtime Memory Language a few seconds ago Accepted 20 ms 9 MB cpp]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Palindrome Number]]></title>
    <url>%2F2019%2F03%2F28%2FLeetcode009-Palindrome%20Number%2F</url>
    <content type="text"><![CDATA[Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 算法思想和第7题差不多，而且说了不让用string，就是第7题之后加个判断，感觉自己在偷懒，但是还是想了好长时间才想出来。 Solution： 1234567891011121314151617181920class Solution &#123;public: bool isPalindrome(int x) &#123; int res = 0, tmp = x; if (x &lt; 0) return false; while (tmp != 0) &#123; int pop = tmp % 10; tmp /= 10; if (res &gt; INT_MAX/10 || (res == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (res &lt; INT_MIN/10 || (res == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; res = res * 10 + pop; &#125; if (res == x) return true; else return false; &#125;&#125;; Time Submitted Status Runtime Memory Language a few seconds ago Accepted 32 ms 8 MB cpp 最近负能量有点多，需要心灵鸡汤透一透，最好是喝完能上头的那种。]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过git将项目上传到github]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%80%9A%E8%BF%87git%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[原文链接：https://blog.csdn.net/jerryhanjj/article/details/72777618 配置Git、SSH 下载、安装Git 绑定用户 12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 配置SSH 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开GitBash），创建SSH Key，密码可以不设置直接回车。 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果一切顺利的话，可以在用户主目录里找到 .ssh​目录，里面有 id_rsa 和id_rsa.pub 两个文件，这两个就是SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。用记事本打开 id_rsa.pub，得到ssh key 公钥。 为 Github 账户添加 ssh key 。登录 Github，展开个人头像的小三角，点settings，然后打开SSH keys菜单，点击Add SSH key新增密钥，填上标题。 上传项目 建立仓库 填一下仓库名称，Initialize this repository with a README是可选的，建议在创建时选上，可以在后面省一个步骤。填好之后，点Create repository完成仓库的建立。 克隆仓库 如果是全新的项目没有任何文件，也可以不用克隆仓库，跳过这一步。点开 Git Shell，进入命令行。首先我们先要把 GitHub 上的我们新建的仓库 clone下来。在初始化版本库之前，先要确认认证的公钥是否正确。 1$ ssh -T git@github.com 如果收到成功的确认消息，就可以开始克隆远程仓库了。 1$ git clone https://github.com/username/program-name.git 克隆仓库之后就在文件夹中出现了项目文件夹及文件,进入项目文件夹，对其进行初始化。 1$ git init 上传README文件 如果在创建 Github 仓库时没有勾选创建 README.md 文件，则要先创建 README.md 文件，不然上传文件会报错。如果已经勾选，可以跳过此步骤。 12345$ git init$ touch README.md$ git add README.md$ git commit -m &apos;first_commit&apos;$ git remote add origin 上传项目 跟踪项目文件夹中的所有文件和文件夹： 1$ git add . 输入本次的提交说明，准备提交暂存区中的更改的已跟踪文件，单引号内为说明内容： 1$ git commit -m &apos;first_commit&apos; 关联远程仓库，添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。 1$ git remote add origin https://github.com/username/program-name.git 如果关联出现错误 fatal: remote origin already exists，则执行git remote rm origin再进行关联。 把本地库的所有内容推送到远程库上： 1$ git push -u origin master 如果在推送时出现错误 error:failed to push som refs to.......，则执行下列语句： 1$ git pull origin master 将远程仓库 Github 上的文件拉下来合并之后重新推送上去。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Reverse Integer]]></title>
    <url>%2F2019%2F03%2F26%2FLeetcode007-Reverse%20Integer%2F</url>
    <content type="text"><![CDATA[Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31}, 2^{31 − 1}]$. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 看起来是一个特别简单的问题，第一想法也是个野路子，先把整型转字符串，再将字符串逆序排列一下，在转换回整型，感觉不妥。 算法思想特别简单， 1res = res * 10 + x % 10; 其实我没想到，看了别人的答案才领悟。 这里很容易懂，但是数据溢出是个大问题，我以为一句 1x &gt;= INT_MIN || x &lt;= INT_MAX 就可以解决了，too young, too naive. 果然要偷偷看答案了。 核心思想： pop = x % 10, If $temp = res\times10 + pop$ causes overflow, then it must be that $res\geq\frac{INTMAX}{10}$ If $res\geq\frac{INTMAX}{10}$, then $temp = res\times10 + pop$ is guaranteed to overflow If $res==\frac{INTMAX}{10}$, then $temp = res\times10 + pop$ will overflow if and only if $pop &gt; 7$ 1234567891011121314class Solution &#123;public: int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; &#125; return rev; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-Two Sum]]></title>
    <url>%2F2019%2F03%2F25%2FLeetcode001-Two%20Sum%2F</url>
    <content type="text"><![CDATA[Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution: 我的解决方案： 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; index; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i; j &lt; nums.size(); j++) &#123; if (i != j &amp;&amp; (nums[i] + nums[j] == target)) &#123; index.push_back(i); index.push_back(j); &#125; &#125; &#125; return index; &#125;&#125;; 12Runtime: 384 ms, faster than 5.00% of C++ online submissions for Two Sum.Memory Usage: 9.4 MB, less than 90.00% of C++ online submissions for Two Sum. 算法比较蠢，单纯的遍历，长路漫漫，还要好好学。 Top Voted Solution： The basic idea is to maintain a hash table for each element num in nums, using num as key and its index (0-based) as value. For each num, search for target - num in the hash table. If it is found and is not the same element as num, then we are done. 12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; indices; for (int i = 0; i &lt; nums.size(); i++) &#123; if (indices.find(target - nums[i]) != indices.end()) &#123; return &#123;indices[target - nums[i]], i&#125;; &#125; indices[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[​ 很早以前就觉得能有一个自己的博客是特别牛X的事情，终于在大神的慢慢影响下，逐渐去学习以前没想过的东西，数学也好，算法也罢，起码每天前进一点。 ​ 终于学会用GitHub搭博客了，照着博客的流程玩了一小天，突然就觉得自己以前好蠢，以后，要保持更新了。]]></content>
  </entry>
</search>
