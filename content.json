{"pages":[],"posts":[{"title":"Leetcode-Two Sum","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution: 我的解决方案： 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; index; for (int i = 0; i &lt; nums.size(); i++) { for (int j = i; j &lt; nums.size(); j++) { if (i != j &amp;&amp; (nums[i] + nums[j] == target)) { index.push_back(i); index.push_back(j); } } } return index; }}; 12Runtime: 384 ms, faster than 5.00% of C++ online submissions for Two Sum.Memory Usage: 9.4 MB, less than 90.00% of C++ online submissions for Two Sum. 算法比较蠢，单纯的遍历，长路漫漫，还要好好学。 Top Voted Solution： The basic idea is to maintain a hash table for each element num in nums, using num as key and its index (0-based) as value. For each num, search for target - num in the hash table. If it is found and is not the same element as num, then we are done. 12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; indices; for (int i = 0; i &lt; nums.size(); i++) { if (indices.find(target - nums[i]) != indices.end()) { return {indices[target - nums[i]], i}; } indices[nums[i]] = i; } return {}; }};","link":"/2019/03/25/Leetcode001-Two Sum/"},{"title":"Leetcode-Reverse Integer","text":"Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31}, 2^{31 − 1}]$. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 看起来是一个特别简单的问题，第一想法也是个野路子，先把整型转字符串，再将字符串逆序排列一下，在转换回整型，感觉不妥。 算法思想特别简单， 1res = res * 10 + x % 10; 其实我没想到，看了别人的答案才领悟。 这里很容易懂，但是数据溢出是个大问题，我以为一句 1x &gt;= INT_MIN || x &lt;= INT_MAX 就可以解决了，too young, too naive. 果然要偷偷看答案了。 核心思想： pop = x % 10, If $temp = res\\times10 + pop​$ causes overflow, then it must be that $res\\geq\\frac{INTMAX}{10}​$ If $res\\geq\\frac{INTMAX}{10}$, then $temp = res\\times10 + pop$ is guaranteed to overflow If $res==\\frac{INTMAX}{10}$, then $temp = res\\times10 + pop$ will overflow if and only if $pop &gt; 7$ 1234567891011121314class Solution {public: int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; } return rev; }};","link":"/2019/03/26/Leetcode007-Reverse Integer/"},{"title":"Leetcode-Reverse Integer","text":"Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 算法思想和第7题差不多，而且说了不让用string，就是第7题之后加个判断，感觉自己在偷懒，但是还是想了好长时间才想出来。 Solution： 1234567891011121314151617181920class Solution {public: bool isPalindrome(int x) { int res = 0, tmp = x; if (x &lt; 0) return false; while (tmp != 0) { int pop = tmp % 10; tmp /= 10; if (res &gt; INT_MAX/10 || (res == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (res &lt; INT_MIN/10 || (res == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; res = res * 10 + pop; } if (res == x) return true; else return false; }}; Time Submitted Status Runtime Memory Language a few seconds ago Accepted 32 ms 8 MB cpp 最近负能量有点多，需要心灵鸡汤透一透，最好是喝完能上头的那种。","link":"/2019/03/28/Leetcode009-Palindrome Number/"},{"title":"Leetcode-Roman to Integer","text":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 最开始想用每种情况都写一遍，虽然会的不多，但还是嫌麻烦，想到了Python中的用两个list去对应相同的索引的不同类型，所以用数组老对应不同的罗马符号。 Solution： 1234567891011121314151617181920212223242526272829class Solution {public: int romanToInt(string s) { int num[] = {1, 5, 10, 50, 100, 500, 1000}; string rom = &quot;IVXLCDM&quot;; vector&lt;int&gt; tmp; int res = 0; for (int i = 0; i &lt; s.size(); i++) { for (int j = 0; j &lt; 7; j++) { if (s[i] == rom[j]) tmp.push_back(num[j]); } } for (int i = 0; i &lt; tmp.size(); i++) { if (i == tmp.size() - 1 || tmp[i] &gt;= tmp[i + 1]) { res += tmp[i]; } else { res -= tmp[i]; } } return res; }}; if (i == tmp.size() - 1 || tmp[i] &gt;= tmp[i + 1])，这里最开始是if(tmp[i] &gt;= tmp[i + 1])，处理&quot;MCDLXXVI&quot;时报错了，输出结果发现最后的I并没有加进去，很神奇，原因还没找到，先留个坑。 Time Submitted Status Runtime Memory Language a few seconds ago Accepted 20 ms 9 MB cpp","link":"/2019/03/29/Leetcode013-Roman to Integer/"},{"title":"Hello World","text":"​ 很早以前就觉得能有一个自己的博客是特别牛X的事情，终于在大神的慢慢影响下，逐渐去学习以前没想过的东西，数学也好，算法也罢，起码每天前进一点。 ​ 终于学会用GitHub搭博客了，照着博客的流程玩了一小天，突然就觉得自己以前好蠢，以后，要保持更新了。","link":"/2019/03/25/hello-world/"},{"title":"通过git将项目上传到github","text":"原文链接：https://blog.csdn.net/jerryhanjj/article/details/72777618 配置Git、SSH 下载、安装Git 绑定用户 12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 配置SSH 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开GitBash），创建SSH Key，密码可以不设置直接回车。 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果一切顺利的话，可以在用户主目录里找到 .ssh​目录，里面有 id_rsa 和id_rsa.pub 两个文件，这两个就是SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。用记事本打开 id_rsa.pub，得到ssh key 公钥。 为 Github 账户添加 ssh key 。登录 Github，展开个人头像的小三角，点settings，然后打开SSH keys菜单，点击Add SSH key新增密钥，填上标题。 上传项目 建立仓库 填一下仓库名称，Initialize this repository with a README是可选的，建议在创建时选上，可以在后面省一个步骤。填好之后，点Create repository完成仓库的建立。 克隆仓库 如果是全新的项目没有任何文件，也可以不用克隆仓库，跳过这一步。点开 Git Shell，进入命令行。首先我们先要把 GitHub 上的我们新建的仓库 clone下来。在初始化版本库之前，先要确认认证的公钥是否正确。 1$ ssh -T git@github.com 如果收到成功的确认消息，就可以开始克隆远程仓库了。 1$ git clone https://github.com/username/program-name.git 克隆仓库之后就在文件夹中出现了项目文件夹及文件,进入项目文件夹，对其进行初始化。 1$ git init 上传README文件 如果在创建 Github 仓库时没有勾选创建 README.md 文件，则要先创建 README.md 文件，不然上传文件会报错。如果已经勾选，可以跳过此步骤。 12345$ git init$ touch README.md$ git add README.md$ git commit -m &apos;first_commit&apos;$ git remote add origin 上传项目 跟踪项目文件夹中的所有文件和文件夹： 1$ git add . 输入本次的提交说明，准备提交暂存区中的更改的已跟踪文件，单引号内为说明内容： 1$ git commit -m &apos;first_commit&apos; 关联远程仓库，添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。 1$ git remote add origin https://github.com/username/program-name.git 如果关联出现错误 fatal: remote origin already exists，则执行git remote rm origin再进行关联。 把本地库的所有内容推送到远程库上： 1$ git push -u origin master 如果在推送时出现错误 error:failed to push som refs to.......，则执行下列语句： 1$ git pull origin master 将远程仓库 Github 上的文件拉下来合并之后重新推送上去。","link":"/2019/03/27/通过git将项目上传到github/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"git","slug":"git","link":"/tags/git/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"else","slug":"else","link":"/categories/else/"}]}