{"pages":[],"posts":[{"title":"C++栈实现分隔符的匹配","text":"栈是一种后进先出(LIFO)的线性数据结构。 栈适用于数据存储后以相反的顺序来检索的情况。站的一个应用是在程序中匹配分隔符。 在C++程序中存在下列分隔符：圆括号”(“和”)“、方括号”[“和”]“、花括号”{“和”}“、注释分隔符”/*“和”*/“ 栈的操作： clear()——清空栈。 isEmpty()——判断栈是否为空。 push(el)——将元素el放到栈的顶部。 pop()——弹出栈顶部的元素。 topEL()——获取栈顶部的元素，不删除。 genStack.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344//******************* genStack.h ************************// generic class for vector implenmentation of stack#ifndef STACK#define STACK#include &lt;vector&gt;using namespace std;template&lt;class T, int capacity = 30&gt;class Stack {public: Stack() { pool.reserve(capacity); } void clear() { pool.clear(); } bool isEmpty() const { return pool.empty(); } T&amp; topEl() { return pool.back(); } T pop() { T el = pool.back(); pool.pop_back(); return el; } void push(const T&amp; el) { pool.push_back(el); }private: vector&lt;T&gt; pool;};#endif genStack.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//******************* genStack.h ************************//用栈实现分隔符的匹配#include &lt;iostream&gt;#include &quot;genStack.h&quot;#include &lt;string&gt;using namespace std;int main() { string str = &quot;s=t[5]+u/(v*(w+y))&quot;; Stack&lt;char&gt; s1; for (int i = 0; i &lt; str.size(); i++) { //注意单引号和双引号的使用！！！ if (str[i] == &apos;(&apos; || str[i] == &apos;[&apos; || str[i] == &apos;{&apos;) { s1.push(str[i]); //cout &lt;&lt; &quot;topEL: &quot; &lt;&lt; s1.topEl() &lt;&lt; endl; } else if (str[i] == &apos;)&apos; || str[i] == &apos;]&apos; || str[i] == &apos;}&apos;) { if ((s1.topEl()==&apos;(&apos; &amp;&amp; str[i]==&apos;)&apos;) || (s1.topEl()==&apos;[&apos; &amp;&amp; str[i]==&apos;]&apos;) || (s1.topEl()==&apos;{&apos; &amp;&amp; str[i]==&apos;}&apos;)) { s1.pop(); } else { cout &lt;&lt; &quot;error!&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } } else if (str[i] == &apos;/&apos;) { if (str[i + 1] == &apos;*&apos;) { for (int j = i; j &lt; str.size(); j++) { if (str[j] == &apos;*&apos; &amp;&amp; str[j + 1] == &apos;/&apos;) { i = j + 1; break; } else if (j == str.size()-1) { cout &lt;&lt; &quot;&apos;/*&apos; can not match &apos;*/&apos;&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } } } else continue; } } if (s1.isEmpty()) cout &lt;&lt; &quot;success!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;failed!&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;}","link":"/2019/04/08/C++栈实现分隔符的匹配/"},{"title":"Leetcode-Reverse Integer","text":"Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31}, 2^{31 − 1}]$. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 看起来是一个特别简单的问题，第一想法也是个野路子，先把整型转字符串，再将字符串逆序排列一下，在转换回整型，感觉不妥。 算法思想特别简单， 1res = res * 10 + x % 10; 其实我没想到，看了别人的答案才领悟。 这里很容易懂，但是数据溢出是个大问题，我以为一句 1x &gt;= INT_MIN || x &lt;= INT_MAX 就可以解决了，too young, too naive. 果然要偷偷看答案了。 核心思想： pop = x % 10, If $temp = res\\times10 + pop​$ causes overflow, then it must be that $res\\geq\\frac{INTMAX}{10}​$ If $res\\geq\\frac{INTMAX}{10}$, then $temp = res\\times10 + pop$ is guaranteed to overflow If $res==\\frac{INTMAX}{10}$, then $temp = res\\times10 + pop$ will overflow if and only if $pop &gt; 7$ 1234567891011121314class Solution {public: int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; } return rev; }};","link":"/2019/03/26/Leetcode007-Reverse Integer/"},{"title":"Leetcode-Palindrome Number","text":"Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 算法思想和第7题差不多，而且说了不让用string，就是第7题之后加个判断，感觉自己在偷懒，但是还是想了好长时间才想出来。 Solution： 1234567891011121314151617181920class Solution {public: bool isPalindrome(int x) { int res = 0, tmp = x; if (x &lt; 0) return false; while (tmp != 0) { int pop = tmp % 10; tmp /= 10; if (res &gt; INT_MAX/10 || (res == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (res &lt; INT_MIN/10 || (res == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; res = res * 10 + pop; } if (res == x) return true; else return false; }}; Time Submitted Status Runtime Memory Language a few seconds ago Accepted 32 ms 8 MB cpp 最近负能量有点多，需要心灵鸡汤透一透，最好是喝完能上头的那种。","link":"/2019/03/28/Leetcode009-Palindrome Number/"},{"title":"Leetcode-Roman to Integer","text":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 最开始想用每种情况都写一遍，虽然会的不多，但还是嫌麻烦，想到了Python中的用两个list去对应相同的索引的不同类型，所以用数组老对应不同的罗马符号。 Solution： 1234567891011121314151617181920212223242526272829class Solution {public: int romanToInt(string s) { int num[] = {1, 5, 10, 50, 100, 500, 1000}; string rom = &quot;IVXLCDM&quot;; vector&lt;int&gt; tmp; int res = 0; for (int i = 0; i &lt; s.size(); i++) { for (int j = 0; j &lt; 7; j++) { if (s[i] == rom[j]) tmp.push_back(num[j]); } } for (int i = 0; i &lt; tmp.size(); i++) { if (i == tmp.size() - 1 || tmp[i] &gt;= tmp[i + 1]) { res += tmp[i]; } else { res -= tmp[i]; } } return res; }}; if (i == tmp.size() - 1 || tmp[i] &gt;= tmp[i + 1])，这里最开始是if(tmp[i] &gt;= tmp[i + 1])，处理&quot;MCDLXXVI&quot;时报错了，输出结果发现最后的I并没有加进去，很神奇，原因还没找到，先留个坑。 Time Submitted Status Runtime Memory Language a few seconds ago Accepted 20 ms 9 MB cpp","link":"/2019/03/29/Leetcode013-Roman to Integer/"},{"title":"Leetcode-Longest Common Prefix","text":"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. Solution： 1234567891011121314151617181920212223242526272829class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { if (strs.size() == 0) return \"\"; int minlen = INT_MAX; string res = \"\"; for (int i = 0; i &lt; strs.size(); i++) { if (strs[i].size() &lt; minlen) minlen = strs[i].size(); } for (int i = 0; i &lt; minlen; i++) { bool flag = true; for (int j = 0; j &lt; strs.size() - 1; j++) { if (strs[j][i] != strs[j + 1][i]) flag = false; } if (flag == true) res = res + strs[0][i]; else break; } return res; }}; 没什么亮点的写法。 Time Submitted Status Runtime Memory Language a few seconds ago Accepted 8 ms 9.1 MB cpp","link":"/2019/03/31/Leetcode014-Longest Common Prefix/"},{"title":"Hello World","text":"​ 很早以前就觉得能有一个自己的博客是特别牛X的事情，终于在大神的慢慢影响下，逐渐去学习以前没想过的东西，数学也好，算法也罢，起码每天前进一点。 ​ 终于学会用GitHub搭博客了，照着博客的流程玩了一小天，突然就觉得自己以前好蠢，以后，要保持更新了。","link":"/2019/03/25/hello-world/"},{"title":"通过git将项目上传到github","text":"原文链接：https://blog.csdn.net/jerryhanjj/article/details/72777618 配置Git、SSH 下载、安装Git 绑定用户 12$ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 配置SSH 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开GitBash），创建SSH Key，密码可以不设置直接回车。 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果一切顺利的话，可以在用户主目录里找到 .ssh​目录，里面有 id_rsa 和id_rsa.pub 两个文件，这两个就是SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。用记事本打开 id_rsa.pub，得到ssh key 公钥。 为 Github 账户添加 ssh key 。登录 Github，展开个人头像的小三角，点settings，然后打开SSH keys菜单，点击Add SSH key新增密钥，填上标题。 上传项目 建立仓库 填一下仓库名称，Initialize this repository with a README是可选的，建议在创建时选上，可以在后面省一个步骤。填好之后，点Create repository完成仓库的建立。 克隆仓库 如果是全新的项目没有任何文件，也可以不用克隆仓库，跳过这一步。点开 Git Shell，进入命令行。首先我们先要把 GitHub 上的我们新建的仓库 clone下来。在初始化版本库之前，先要确认认证的公钥是否正确。 1$ ssh -T git@github.com 如果收到成功的确认消息，就可以开始克隆远程仓库了。 1$ git clone https://github.com/username/program-name.git 克隆仓库之后就在文件夹中出现了项目文件夹及文件,进入项目文件夹，对其进行初始化。 1$ git init 上传README文件 如果在创建 Github 仓库时没有勾选创建 README.md 文件，则要先创建 README.md 文件，不然上传文件会报错。如果已经勾选，可以跳过此步骤。 12345$ git init$ touch README.md$ git add README.md$ git commit -m &apos;first_commit&apos;$ git remote add origin 上传项目 跟踪项目文件夹中的所有文件和文件夹： 1$ git add . 输入本次的提交说明，准备提交暂存区中的更改的已跟踪文件，单引号内为说明内容： 1$ git commit -m &apos;first_commit&apos; 关联远程仓库，添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。 1$ git remote add origin https://github.com/username/program-name.git 如果关联出现错误 fatal: remote origin already exists，则执行git remote rm origin再进行关联。 把本地库的所有内容推送到远程库上： 1$ git push -u origin master 如果在推送时出现错误 error:failed to push som refs to.......，则执行下列语句： 1$ git pull origin master 将远程仓库 Github 上的文件拉下来合并之后重新推送上去。","link":"/2019/03/27/通过git将项目上传到github/"},{"title":"Leetcode-Two Sum","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution: 我的解决方案： 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; index; for (int i = 0; i &lt; nums.size(); i++) { for (int j = i; j &lt; nums.size(); j++) { if (i != j &amp;&amp; (nums[i] + nums[j] == target)) { index.push_back(i); index.push_back(j); } } } return index; }}; 12Runtime: 384 ms, faster than 5.00% of C++ online submissions for Two Sum.Memory Usage: 9.4 MB, less than 90.00% of C++ online submissions for Two Sum. 算法比较蠢，单纯的遍历，长路漫漫，还要好好学。 Top Voted Solution： The basic idea is to maintain a hash table for each element num in nums, using num as key and its index (0-based) as value. For each num, search for target - num in the hash table. If it is found and is not the same element as num, then we are done. 12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; indices; for (int i = 0; i &lt; nums.size(); i++) { if (indices.find(target - nums[i]) != indices.end()) { return {indices[target - nums[i]], i}; } indices[nums[i]] = i; } return {}; }};","link":"/2019/03/25/Leetcode001-Two Sum/"},{"title":"C++调用Python版Mask-R-CNN并传递和接收参数","text":"想做一个用Mask R-CNN只检测人的demo，发现github已经有人用Python实现了，但后处理用的是C++，所以想直接用C++器调用python，再将需要的结果返回给C++。 运行环境： Visual Studio 2015，Python3.6（Anaconda），OpenCV3.4.2（C++），tensorflow1.12，Keras2.0.8 C++环境配置 配置OpenCV 新建一个C++工程； 右键属性$\\rightarrow$C++目录$\\rightarrow$包含目录$\\rightarrow$点击编辑，将 123D:\\Programs\\opencv\\build\\includeD:\\Programs\\opencv\\build\\include\\opencvD:\\Programs\\opencv\\build\\include\\opencv2 加入包含目录，注意配置的方案平台版本和当前运行的一致； 右键属性$\\rightarrow$C++目录$\\rightarrow$库目录$\\rightarrow​$点击编辑，将 1D:\\Programs\\opencv\\build\\x64\\vc14\\lib 加入库目录，注意VS的版本，2017改用vc15的目录； 右键属性$\\rightarrow$链接器$\\rightarrow$输入$\\rightarrow$点击编辑，将 1opencv_world342.lib 加入其中。 配置Python环境 右键属性$\\rightarrow$C++目录$\\rightarrow$包含目录$\\rightarrow​$点击编辑，将 12D:\\Programs\\Anaconda3\\includeD:\\Programs\\Anaconda3\\Lib\\site-packages\\numpy\\core\\include 加入到包含目录中； 右键属性$\\rightarrow$C++目录$\\rightarrow$库目录$\\rightarrow$点击编辑，将 12D:\\Programs\\Anaconda3\\libsD:\\Programs\\Anaconda3\\Lib\\site-packages\\numpy\\core\\lib 加入库目录; 右键属性$\\rightarrow$链接器$\\rightarrow$输入$\\rightarrow$点击编辑，将 1python36.lib 加入其中，注意只有python36，没有python36d，所以调试的时候要用relese的版本，debug的版本会报错。 调用Python 从C++输入图片数据 由于C++用OpenCV读取的图片格式和Mask R-CNN的输入格式不同，所以需要先用C++处理好图片，传递给Python。 12345678910111213141516171819202122232425262728Mat img = imread(&quot;./image.jpg&quot;);auto sz = img.size();int x = sz.width;int y = sz.height;int z = img.channels();uchar *CArrays = new uchar[x*y*z];int iChannels = img.channels();int iRows = img.rows;int iCols = img.cols * iChannels;if (img.isContinuous()){ iCols *= iRows; iRows = 1;}uchar* p;int id = -1;for (int i = 0; i &lt; iRows; i++){ // get the pointer to the ith row p = img.ptr&lt;uchar&gt;(i); // operates on each pixel for (int j = 0; j &lt; iCols; j++) { CArrays[++id] = p[j];//连续空间 }}npy_intp Dims[3] = {y, x, z}; //注意这个维度数据！PyObject *PyArray = PyArray_SimpleNewFromData(3, Dims, NPY_UBYTE, CArrays); 调用Mask R-CNN 1234567891011121314151617181920212223242526272829303132333435363738394041//初始化pythonPy_Initialize();import_array();PyRun_SimpleString(&quot;import sys&quot;); PyRun_SimpleString(&quot;sys.path.append(r&apos;C:\\\\Users\\\\Administrator\\\\Documents\\\\Keypoints-of-humanpose-with-Mask-R-CNN-master&apos;)&quot;);//定义python类型的变量PyObject *pModule = NULL;PyObject *pFunc = NULL;PyObject *pArg = NULL;PyObject *result = NULL;PyObject *pDict = NULL;//直接运行python代码PyRun_SimpleString(&quot;print(&apos;python start&apos;)&quot;);PyObject *ArgList = PyTuple_New(1);...PyTuple_SetItem(ArgList, 0, PyArray);//引入模块pModule = PyImport_ImportModule(&quot;human_detected&quot;);if (!pModule){ cout &lt;&lt; &quot;Import Module Failed&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;}//获取模块字典属性pDict = PyModule_GetDict(pModule);//直接获取模块中的函数pFunc = PyObject_GetAttrString(pModule, &quot;detect&quot;);... Mask R-CNN接受参数并返回值 Mask R-CNN检测人项目地址：https://github.com/Junyuan12/Mask_RCNN_Humanpose Mask R-CNN的配置就不细说了，网上有很多教程，主要是windows下配置pycocotools可能会有问题， windows下pycocotools安装教程：https://blog.csdn.net/qq_29592829/article/details/82877494 在Mask R-CNN中新建一个py文件，human_detected.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import osimport sysimport randomimport mathimport numpy as npimport skimage.ioimport matplotlibimport matplotlib.pyplot as pltimport cocoimport utilsimport model as modellibimport visualizefrom model import logimport cv2def detect(image): # print(image) ROOT_DIR = os.getcwd() # Directory to save logs and trained model MODEL_DIR = os.path.join(ROOT_DIR, &quot;mylogs&quot;) # Local path to trained weights file COCO_MODEL_PATH = os.path.join(ROOT_DIR, &quot;mask_rcnn_coco_humanpose.h5&quot;) # Download COCO trained weights from Releases if needed if not os.path.exists(COCO_MODEL_PATH): utils.download_trained_weights(COCO_MODEL_PATH) class InferenceConfig(coco.CocoConfig): GPU_COUNT = 1 IMAGES_PER_GPU = 1 KEYPOINT_MASK_POOL_SIZE = 7 inference_config = InferenceConfig() # Recreate the model in inference mode model = modellib.MaskRCNN(mode=&quot;inference&quot;, config=inference_config, model_dir=MODEL_DIR) # Get path to saved weights model_path = os.path.join(ROOT_DIR, &quot;mask_rcnn_coco_humanpose.h5&quot;) assert model_path != &quot;&quot;, &quot;Provide path to trained weights&quot; print(&quot;Loading weights from &quot;, model_path) model.load_weights(model_path, by_name=True) # COCO Class names #For human pose task We just use &quot;BG&quot; and &quot;person&quot; class_names = [&apos;BG&apos;, &apos;person&apos;] #BGR-&gt;RGB image = image[:,:,::-1] #print(np.shape(image)) # Run detection results = model.detect_keypoint([image], verbose=1) r = results[0] # for one image log(&quot;rois&quot;,r[&apos;rois&apos;]) log(&quot;keypoints&quot;,r[&apos;keypoints&apos;]) log(&quot;class_ids&quot;,r[&apos;class_ids&apos;]) log(&quot;keypoints&quot;,r[&apos;keypoints&apos;]) log(&quot;masks&quot;,r[&apos;masks&apos;]) log(&quot;scores&quot;,r[&apos;scores&apos;]) visualize.display_instances(image, r[&apos;rois&apos;], r[&apos;masks&apos;], r[&apos;class_ids&apos;], class_names, r[&apos;scores&apos;]) flat_roi = r[&apos;rois&apos;].flatten() print(flat_roi) return flat_roi 其中包括一个函数detect(image)，用于接受C++传进来的图片，并最终返回每个人的roi。 C++接受返回参数 python将结果展开成一列，C++接受返回的一维数组并输出： 1234567891011121314151617181920212223// 调用直接获得的函数,并传递参数PyObject *pReturn = PyObject_CallObject(pFunc, ArgList);//获取python程序的返回结果//以下是对返回的一维数组结果进行处理if (pReturn){ //将结果类型转换成数组对象类型 PyArrayObject *pyResultArr = (PyArrayObject *)pReturn; //从Python中的PyArrayObject解析出数组数据为c的double类型。 int *resDataArr = (int *)PyArray_DATA(pyResultArr); int dimNum = PyArray_NDIM(pyResultArr);//返回数组的维度数，此处恒为1 npy_intp *pdim = PyArray_DIMS(pyResultArr);//返回数组各维度上的元素个数值 //以下是对返回结果的输出显示 for (int i = 0; i &lt; dimNum; ++i) { for (int j = 0; j &lt; pdim[0]; ++j) cout &lt;&lt; resDataArr[i * pdim[0] + j] &lt;&lt; &quot;,&quot;; } cout &lt;&lt; endl;} 完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;Python.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;numpy/arrayobject.h&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;using namespace std;int main(int argc, char* argv[]){ cv::Mat img = cv::imread(&quot;./image.jpg&quot;); //初始化python Py_Initialize(); import_array(); PyRun_SimpleString(&quot;import sys&quot;); PyRun_SimpleString(&quot;sys.path.append(r&apos;C:\\\\Users\\\\Administrator\\\\Documents\\\\Keypoints-of-humanpose-with-Mask-R-CNN-master&apos;)&quot;); //PyRun_SimpleString(&quot;print(sys.path)&quot;); //定义python类型的变量 PyObject *pModule = NULL; PyObject *pFunc = NULL; PyObject *pArg = NULL; PyObject *result = NULL; PyObject *pDict = NULL; //直接运行python代码 PyRun_SimpleString(&quot;print(&apos;python start&apos;)&quot;); PyObject *ArgList = PyTuple_New(1); auto sz = img.size(); int x = sz.width; int y = sz.height; int z = img.channels(); uchar *CArrays = new uchar[x*y*z]; int iChannels = img.channels(); int iRows = img.rows; int iCols = img.cols * iChannels; if (img.isContinuous()) { iCols *= iRows; iRows = 1; } uchar* p; int id = -1; for (int i = 0; i &lt; iRows; i++) { // get the pointer to the ith row p = img.ptr&lt;uchar&gt;(i); // operates on each pixel for (int j = 0; j &lt; iCols; j++) { CArrays[++id] = p[j];//连续空间 } } npy_intp Dims[3] = { y, x, z }; //注意这个维度数据！ PyObject *PyArray = PyArray_SimpleNewFromData(3, Dims, NPY_UBYTE, CArrays); PyTuple_SetItem(ArgList, 0, PyArray); //引入模块 pModule = PyImport_ImportModule(&quot;human_detected&quot;); if (!pModule) { cout &lt;&lt; &quot;Import Module Failed&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } //获取模块字典属性 pDict = PyModule_GetDict(pModule); //直接获取模块中的函数 pFunc = PyObject_GetAttrString(pModule, &quot;detect&quot;); // 调用直接获得的函数,并传递参数 PyObject *pReturn = PyObject_CallObject(pFunc, ArgList); //获取python程序的返回结果 //以下是对返回的一维数组结果进行处理 if (pReturn) { //将结果类型转换成数组对象类型 PyArrayObject *pyResultArr = (PyArrayObject *)pReturn; //从Python中的PyArrayObject解析出数组数据为c的double类型。 int *resDataArr = (int *)PyArray_DATA(pyResultArr); int dimNum = PyArray_NDIM(pyResultArr);//返回数组的维度数，此处恒为1 npy_intp *pdim = PyArray_DIMS(pyResultArr);//返回数组各维度上的元素个数值 //以下是对返回结果的输出显示 for (int i = 0; i &lt; dimNum; ++i) { for (int j = 0; j &lt; pdim[0]; ++j) cout &lt;&lt; resDataArr[i * pdim[0] + j] &lt;&lt; &quot;,&quot;; } cout &lt;&lt; endl; } PyRun_SimpleString(&quot;print(&apos;python end&apos;)&quot;); ////释放python Py_Finalize(); system(&quot;pause&quot;); return 0;}","link":"/2019/03/31/C++调用Python版Mask-R-CNN并传递和接收参数/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"else","slug":"else","link":"/categories/else/"}]}