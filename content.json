{"pages":[],"posts":[{"title":"Hello World","text":"​ 很早以前就觉得能有一个自己的博客是特别牛X的事情，终于在大神的慢慢影响下，逐渐去学习以前没想过的东西，数学也好，算法也罢，起码每天前进一点。 ​ 终于学会用GitHub搭博客了，照着博客的流程玩了一小天，突然就觉得自己以前好蠢，以后，要保持更新了。","link":"/2019/03/25/hello-world/"},{"title":"Leetcode-Two Sum","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Solution: 我的解决方案： 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; index; for (int i = 0; i &lt; nums.size(); i++) { for (int j = i; j &lt; nums.size(); j++) { if (i != j &amp;&amp; (nums[i] + nums[j] == target)) { index.push_back(i); index.push_back(j); } } } return index; }}; 12Runtime: 384 ms, faster than 5.00% of C++ online submissions for Two Sum.Memory Usage: 9.4 MB, less than 90.00% of C++ online submissions for Two Sum. 算法比较蠢，单纯的遍历，长路漫漫，还要好好学。 Top Voted Solution： The basic idea is to maintain a hash table for each element num in nums, using num as key and its index (0-based) as value. For each num, search for target - num in the hash table. If it is found and is not the same element as num, then we are done. 12345678910111213class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; indices; for (int i = 0; i &lt; nums.size(); i++) { if (indices.find(target - nums[i]) != indices.end()) { return {indices[target - nums[i]], i}; } indices[nums[i]] = i; } return {}; }};","link":"/2019/03/25/Leetcode-Two Sum/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"}]}